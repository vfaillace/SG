import random
import functools
from datetime import datetime
import time as time_module
import simpy
import numpy as np
import pandas as pd
import csv
import threading
import queue
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from M2.SimComponents import PacketGenerator, PacketSink, SwitchPort, PortMonitor


import time
# Global variable definition
time_s = datetime.now()
time_e = datetime.now()
print_lock = threading.Lock()
all_data = []
simulation_running = True
dos_attack_active = False


"""
Simulate some characteristics of a dos attack through the following approaches:
1) High Traffic Volume: During the dos attack simulation, the dos_attack function continuously generates traffic from the specified attack source bus (attack_fb) 
    to all other buses (i). This constant generation of traffic from a single source mimics the high volume of traffic generated by a dos attack.

2) Lower Port Rate and Queue Limit: In the Rhop1 function, when the is_attack parameter is set to True (during the dos attack simulation), the port_rate and qlimit 
    parameters for the SwitchPort are set to lower values (port_rate_attack and qlimit_attack). This simulates a scenario where the network resources (port rate and 
    queue limit) are overwhelmed by the high volume of attack traffic, leading to packet drops and increased queuing delays.

3) Random Delays between Attack Packets: The dos_attack function introduces random delays between sending attack packets using time.sleep(random.uniform(0.1, 0.5)). 
    This simulates the potential variations in the timing of attack packets, which can be observed in some dos attacks.
"""

    
# Global variable definition
time_s = datetime.now()
time_e = datetime.now()
print_lock = threading.Lock()
all_data = []
simulation_running = True

def send_to_queue_and_process(data, output_queue, is_attack=False):
    list_column = [
        "FB", "TB", "IAT", "TD", "Arrival Time", "PC", "Packet Size",
        "Acknowledgement Packet Size", "RTT", "Average Queue Size",
        "System Occupancy", "Arrival Rate", "Service Rate", "Packet Dropped",
        "Time", "Sample", "Is Attack"
    ]
    data_dict = dict(zip(list_column, data))
    
    with print_lock:
        if is_attack:
            print(f"DOS Attack: From Bus {data_dict['FB']} to Bus {data_dict['TB']}")
    
    # Put the data into the queue for processing
    output_queue.put(data_dict)
    
    # Store data for CSV output
    all_data.append(data)

# Set up arrival and packet size distributions
adistl = np.zeros(shape=(1000))
for i in range(1000):
    adistl[i] = random.expovariate(0.5)

def adist():
    return random.choice(adistl)

sdist_list = np.zeros(shape=(1000))
for i in range(1000):
    sdist_list[i] = random.expovariate(0.1)

def sdist():
    return random.choice(sdist_list)

sdistL = np.zeros(shape=(1000))
for i in range(1000):
    sdistL[i] = 1300

def sdistL():
    return random.choice(sdistL)

sdistLack = np.zeros(shape=(1000))
for i in range(1000):
    sdistLack[i] = 64

def sdistLack():
    return random.choice(sdistLack)

samp_dist_list = np.zeros(shape=(1000))
for i in range(1000):
    samp_dist_list[i] = random.expovariate(1.0)

def samp_dist():
    return random.choice(samp_dist_list)

def Rhop1(from_bus, to_bus, time_s, time_e, sampl, process_func, is_attack=False):
    """
    Function to simulate a single-hop network and measure various metrics.
    """
    k = 1
    pd = 0
    env = simpy.Environment()

    # Create packet generators and sink
    a = random.expovariate(7)

    def arr():
        return a if not is_attack else random.expovariate(1000)

    s = random.expovariate(0.001)

    def psz():
        return s

    sa = random.expovariate(0.064)

    def sack():
        return sa

    AR = float(s) / float(a)
    ps = PacketSink(env, debug=False, rec_arrivals=True, absolute_arrivals=False)
    pg = PacketGenerator(env, "Greg", arr, psz)
    switch_port = SwitchPort(env, port_rate_norm if not is_attack else port_rate_attack, qlimit_norm if not is_attack else qlimit_attack)
    pm = PortMonitor(env, switch_port, samp_dist)

    # Wire packet generators, switch ports, and sinks together
    pg.out = switch_port
    switch_port.out = ps

    # Run simulation


    # start_time = time.time()
    env.run(until=15)
    # end_time = time.time()
    # computation_time = end_time - start_time

    # events_processed = env.now  #number of events processed
    # print(f"Processed {events_processed} events in {computation_time} seconds")
    # print(f"Average time per event: {computation_time / events_processed} seconds")

    pg2 = PacketGenerator(env, "", arr, sack)
    ps2 = PacketSink(env, debug=False, rec_arrivals=True, absolute_arrivals=False)
    pg2.out = switch_port
    switch_port.out = ps2

    # start_time = time.time()
    env.run(until=16)
    # end_time = time.time()
    # computation_time = end_time - start_time

    # events_processed = env.now  #number of events processed
    # print(f"Processed {events_processed} events in {computation_time} seconds")
    # print(f"Average time per event: {computation_time / events_processed} seconds")
    # exit(1)

    # Calculate metrics
    RTT = sum(ps.waits) / len(ps.waits) if len(ps.waits) > 0 else 0
    RTT += sum(ps2.waits) / len(ps2.waits) if len(ps2.waits) > 0 else 0
    RTT += sum(ps.arrivals) / len(ps.arrivals)
    TD = sum(ps.waits) / len(ps.waits) if len(ps.waits) > 0 else 0
    IAT = a
    AT = sum(ps.arrivals) / len(ps.arrivals)
    pasz = s
    acksz = sa

    for i in range(len(pm.sizes)):
        if pm.sizes[i] != 0:
            k += 1

    so = sum(pm.sizes) / len(pm.sizes)
    if so == 0:
        sr = AR
    else:
        sr = AR / so

    avqs = sum(pm.sizes) / k
    pd = pg.packets_sent - ps.packets_rec
    time_now = datetime.now()
    timed = time_module.time()
    Time = time_now.strftime("%H:%M:%S:%f")

    # Send data to queue immediately
    send_to_queue_and_process([
        from_bus, to_bus, IAT, TD, AT, ps.packets_rec, pasz, acksz,
        RTT, avqs, so, AR, sr, pd, Time, sampl, 1 if is_attack else 0
    ], process_func, is_attack)

    return (
        sr, acksz, pasz, AT, avqs, so, AR, timed, Time, RTT, TD, IAT, ps.packets_rec, pd, 1 if is_attack else 0,
    )
    
def busping(fb, n, sampl, process_func):
    global dos_attack_active
    while simulation_running:
        for i in range(1, n):
            if fb != i and (fb != dos_fb or not dos_attack_active):
                try:
                    Rhop1(fb, i, time_s, time_e, sampl, process_func, is_attack=False)
                except Exception as e:
                    print(f"Exception occurred in Rhop1 during busping: {str(e)}")
        time_module.sleep(random.uniform(0.5, 1.0))  # Add some delay between iterations

def dos_attack(duration, attack_fb, sampl, process_func):
    global dos_attack_active
    start_time = time_module.time()
    end_time = start_time + duration
    dos_attack_active = True
    while simulation_running and time_module.time() < end_time:
        for i in range(1, n):
            if attack_fb != i:
                try:
                    Rhop1(attack_fb, i, time_s, time_e, sampl, process_func, is_attack=True)
                except Exception as e:
                    print(f"Exception occurred in Rhop1 during dos attack: {str(e)}")
        time_module.sleep(random.uniform(0.1, 0.5))  # Add random delays between attack packets
    dos_attack_active = False
    print(f"DoS attack from Bus {attack_fb} has ended.")

# Variables for switch function in simulation
port_rate_norm = 100000.0
qlimit_norm = 1000000
port_rate_attack = 10000.0  # Lower port rate for attack traffic
qlimit_attack = 100000  # Lower queue limit for attack traffic
n = 4
dos_fb = 2
def run_simulation(output_queue):
    global simulation_running
    global dos_attack_active
    start = time_module.time()
    sampl = 1

    dos_duration = 30  # Duration of the dos attack in seconds
    simulation_duration = 120  # Total simulation time in seconds


    dos_duration = 30  # Duration of the dos attack in seconds
    simulation_duration = 120  # Total simulation time in seconds

    # Start threads for each bus
    threads = []
    for bus in [1, 2, 3]: 

        t = threading.Thread(target=busping, args=(bus, n, sampl, output_queue))
        t.start()
        threads.append(t)

    # Start dos attack thread
    dos_thread = threading.Thread(target=dos_attack, args=(dos_duration, dos_fb, sampl, output_queue))
    dos_thread.start()
    threads.append(dos_thread)

    # Run simulation for the specified duration
    time_module.sleep(simulation_duration)

    # Signal threads to stop
    simulation_running = False

    # Wait for all threads to complete
    for t in threads:
        t.join()

    print("Simulation complete")

    # Write all data to CSV file
    write_to_csv()
    
    # Signal that the simulation is complete
    output_queue.put(None)
    
def write_to_csv():
    list_column = [
        "FB", "TB", "IAT", "TD", "Arrival Time", "PC", "Packet Size",
        "Acknowledgement Packet Size", "RTT", "Average Queue Size",
        "System Occupancy", "Arrival Rate", "Service Rate", "Packet Dropped",
        "Time", "Sample", "Is Attack"
    ]
    
    with open("network_traffic.csv", "w", newline="") as entry:
        writer = csv.writer(entry)
        writer.writerow(list_column)
        writer.writerows(all_data)
    
    print("CSV file 'network_traffic.csv' has been created with all simulation data.")
if __name__ == "__main__":
    output_queue = queue.Queue()
    run_simulation(output_queue)